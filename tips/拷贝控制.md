# 拷贝控制

## TODO

- 阻止拷贝 p451
- 练习13.21 P452

## 特殊的成员函数

- 拷贝构造,构造函数第一个参数是自身类型的**引用**,几乎都是`const`的引用,其他参数有默认值,拷贝构造一般不使用显式`explict`,因为经常需要隐式使用.编译器会自动生成一个**合成拷贝构造函数**,将类成员依次拷贝

- 拷贝赋值

- 移动构造

- 移动赋值

- 析构函数

  

## 拷贝初始化与直接初始化

> https://blog.csdn.net/twdlll/article/details/78302349

- 直接初始化是编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数**直接初始化有可能调用拷贝构造函数**

- 拷贝初始化要求将右侧的对象拷贝到创建的对象中,如果需要还要进行类型转换 **直接初始化有可能调用拷贝构造函数**

  ```cpp
  string dots(10, '.'); 	// direct initialization
  string s(dots); 		// direct initialization  这里使用的是拷贝构造函数,而不是合成的
  string s2 = dots; 		// copy initialization
  string null_book = "9-999-99999-9"; // copy initialization
  string nines = string(100, '9'); 	// copy initialization
  ```

- 拷贝初始化不仅在`=`时发生,还有以下情况
  1. 将一个对象实参传递给非引用类型的形参
  2. 返回类型非引用,返回一个对象
  3. 使用花括号列表初始化数组元素或者聚合类
  4. 容器的`insert,push_back`使用拷贝初始化,`emplace`使用直接初始化,因为他是去调用构造函数的

## 匿名对象

```cpp
class A
{
	A(int t)
}
A a1=A(5);  // 这里是直接用a1作为A(5)这个匿名对象的别名,而没有先构造匿名对象,再去复制
应该优化成这个样子了
A a1(5);

```

## 赋值运算符

```cpp
class A
{
	&A operator=(){ return *this;}
}
```

## 析构函数

析构函数体自身不直接销毁成员,成员是在函数体之后隐藏的洗后阶段销毁的.

## 三五法则

1. 如果需要析构函数,那么也需要拷贝构造和拷贝赋值.因为如果需要析构,说明有动态内存,那么复制和赋值时就需要新开辟内存
2. 如果需要拷贝构造,那么也需要拷贝赋值,比如类内部需要一个唯一的ID
3. 如果一个类定义里任何一个拷贝操作,它应该定义所有的5个操作,拷贝构造,赋值,移动构造,赋值,析构函数

## 拷贝赋值隐含的

1. 一般拷贝赋值会先删除自身之前的资源,再拷贝新资源,也就是他会先调用类似析构,然后执行类似拷贝构造

2. 很多情况下拷贝赋值可以使用拷贝加交换的操作,参数注意是传值而非传引用 p519

   ```
   HasPtr& HasPtr::operator=(HasPtr & a) //这里先拷贝了副本
   {
   	swap(*this,a);	//a指向this原来的内存
   	return *this;   //a被销毁,意味着原来最开始this的内存销魂
   }
   ```

## 赋值形参为非引用

赋值形参如果为非引用,会先调用构造函数,根据实参调用拷贝构造还是移动构造

```
HasPtr& operator=(Hasptr s){.....}

h1=h2; //调用拷贝构造,h2为左值
h1=std::move(h2)// 如果定义了移动构造,则先调用移动构造,再调用析构函数释放临时的实参对象
```

